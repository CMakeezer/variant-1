<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <!-- TITLE -->
    <title>Eggs.Variant</title>

    <!-- DESCRIPTION -->
    <meta name="description" content="">

    <!-- CSS3 -->
    <link rel="stylesheet" type="text/css" href="css/normalize.css?v=2.0" />
    <link rel="stylesheet" type="text/css" href="css/main.css?v=2.0" />

    <!-- FAVICON -->
    <link rel="shortcut icon" href="css/img/favicon.ico" type="image/x-icon" />
</head>
<body>
    <div id="container">
        <header id="head">
            <div class="top">
                <img src="logo.png" class="logo" />
                <a href="http://eggs-cpp.github.io/variant/">
                    Eggs.Variant
                </a>
            </div>
            <div class="nav">
                <a href="introduction.html"><img src="css/img/prev.png" alt="Prev"></a>
                <a href="index.html"><img src="css/img/home.png" alt="Home"></a>
                <a href="reference.html"><img src="css/img/next.png" alt="Next"></a>
            </div>
        </header>
        <div class="design">
            <section>
                <a name='design' href='#design'>
                    <h1>Design</h1>
                </a>
                <p>The ultimate design goal is to generalize and enhance the <em>discriminated <code>union</code></em> construct, without compromising its functionality. That is, there should be little or no room for choosing:</p>
<pre class="code">
<span style="color:blue;">struct</span> U {
&nbsp;&nbsp;<span style="color:blue;">union</span> { T0 m0; ...; TN mN; };
&nbsp;&nbsp;std::<span style="color:#2b91af;">size_t</span> which;
} u;
</pre>
                <p>over:</p>
<pre class="code">
<span style="color:blue;">using</span> V = eggs::<span style="color:#2b91af;">variant</span>&lt;T0, ..., TN&gt;;
V v;
</pre>
                <p>In particular:</p>
                <ul>
                    <li><p>The size of <code>V</code> shall match that of the corresponding <code>U</code>. Any active member of <code>v</code> shall be allocated in a region of <code>V</code> suitably aligned for the types <code>T0, ... TN</code>; the use of additional storage, such as dynamic memory, is not permitted.</p></li>
                    <li><p>Well defined semantics of <code>u</code> shall be matched or improved by <code>v</code>. Undefined behavior, such as referring to a non-active member of <code>u</code>, shall not be allowed by the interface of <code>v</code>.</p></li>
                    <li><p>All special member functions shall be provided by <code>V</code> with the expected semantics.</p></li>
                </ul>
                <p>The interface is largely based on that of <a href="http://en.cppreference.com/w/cpp/experimental/optional" title="std::experimental::optional - cppreference.com"><code>std::experimental::optional&lt;T&gt;</code></a>, as defined by the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4082.pdf" title="C++ Extensions for Library Fundamentals">Library Fundamentals TS</a>. The conceptual model for <code>optional&lt;T&gt;</code> is that of a <em>discriminated <code>union</code></em> of types <code>nullopt_t</code> and <code>T</code>. The design decisions taken for <code>optional&lt;T&gt;</code> easily translate to <code>variant&lt;Ts...&gt;</code>, whose conceptual model is that of a <em>discriminated <code>union</code></em> of types <code>nullvariant_t</code> and those in <code>Ts</code>. The semantics of all special member functions and relational operators, as well as the interface for switching the active member &mdash;via construction, assignment, or emplacement&mdash;, derives from <code>optional&lt;T&gt;</code>.</p>
                <p>Access to the active member is based on the design of <a href="http://en.cppreference.com/w/cpp/utility/functional/function" title="std::function - cppreference.com"><code>std::function</code></a>, which gives back a pointer to the target if queried with the correct target type &mdash;as a poor man's <code>dynamic_cast</code>&mdash;. Additionally, it is also possible to obtain a <code>void</code> pointer to the active member (if any), which proved useful to simplify the implementation of helper functions.</p>
                <p>Finally, helper classes similar to those of <a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple" title="std::tuple - cppreference.com"><code>std::tuple</code></a> are provided, as well as index or type based element access &mdash;albeit with surprising semantics, closer to those of a runtime-checked cast&mdash;.</p>
            </section>
        </div>

        <hr>
        <p>
            Copyright
            <em>Agust&iacute;n Berg&eacute;</em>,
            <em>Fusion Fenix</em> 2014-2017
        </p>

        <p>
            Distributed under the Boost Software License, Version 1.0. (See accompanying
            file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
        </p>
    </div>
</body>
</html>
