<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <!-- TITLE -->
    <title>Eggs.Variant</title>

    <!-- DESCRIPTION -->
    <meta name="description" content="">

    <!-- CSS3 -->
    <link rel="stylesheet" type="text/css" href="css/normalize.css?v=2.0" />
    <link rel="stylesheet" type="text/css" href="css/main.css?v=2.0" />

    <!-- FAVICON -->
    <link rel="shortcut icon" href="css/img/favicon.ico" type="image/x-icon" />
</head>
<body>
    <div id="container">
        <header id="head">
            <div class="top">
                <img src="logo.png" class="logo" />
                <a href="http://eggs-cpp.github.io/variant/">
                    Eggs.Variant
                </a>
            </div>
            <div class="nav">
                <a href="design.html"><img src="css/img/prev.png" alt="Prev"></a>
                <a href="index.html"><img src="css/img/home.png" alt="Home"></a>
                <a href="config.html"><img src="css/img/next.png" alt="Next"></a>
            </div>
        </header>
        <div class="reference">
            <section>
                <a name='reference' href='#reference'>
                    <h1>Reference</h1>
                </a>
<pre class="code">
<span style="color:blue;">namespace</span> eggs { <span style="color:blue;">namespace</span> variants {
&nbsp;&nbsp;<span style="color:green;">// variant for object types</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt; <span style="color:blue;">class</span> <a href="#eggs-variant"><span style="color:#2b91af;">variant</span></a>;

&nbsp;&nbsp;<span style="color:green;">// In-place construction</span>
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-inplace"><span style="color:#2b91af;">in_place_tag</span></a> {};
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I&gt;
&nbsp;&nbsp;<span style="color:blue;">using</span> <a href="#eggs-inplace"><span style="color:#2b91af;">in_place_index_t</span></a> = <span style="color:#2b91af;">in_place_tag</span>(&amp;)(<em>unspecified&lt;<span style="color:#2b91af;">I</span>&gt;</em>);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">using</span> <a href="#eggs-inplace"><span style="color:#2b91af;">in_place_type_t</span></a> = <span style="color:#2b91af;">in_place_tag</span>(&amp;)(<em>unspecified&lt;<span style="color:#2b91af;">T</span>&gt;</em>);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I&gt;
&nbsp;&nbsp;<span style="color:#2b91af;">in_place_tag</span> <a href="#eggs-inplace"><span style="color:magenta;">in_place</span></a>(<em>unspecified&lt;<span style="color:#2b91af;">I&gt;</span></em>);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:#2b91af;">in_place_tag</span> <a href="#eggs-inplace"><span style="color:magenta;">in_place</span></a>(<em>unspecified&lt;<span style="color:#2b91af;">T&gt;</span></em>);

&nbsp;&nbsp;<span style="color:green;">// Class bad_variant_access</span>
&nbsp;&nbsp;<span style="color:blue;">class</span> <a href="#eggs-bad-variant-access"><span style="color:#2b91af;">bad_variant_access</span></a>;

&nbsp;&nbsp;<span style="color:green;">// Class template variant</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">class</span> <a href="#eggs-variant"><span style="color:#2b91af;">variant</span></a> {
&nbsp;&nbsp;<span style="color:blue;">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">static</span> <span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> <span style="color:magenta;">npos</span> = std::<span style="color:#2b91af;">size_t</span>(<span style="color:magenta;">-1</span>);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">// Constructors</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-1">variant</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-2">variant</a>(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-3">variant</a>(<span style="color:#2b91af;">variant</span>&amp;&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-4">variant</a>(<span style="color:#2b91af;">U</span>&amp;&amp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-5">variant</a>(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-6">variant</a>(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-7">variant</a>(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-8">variant</a>(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">// Destructor</span>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#eggs-variant-dtor-1">~variant</a>();

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">// Assignment</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-1"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-2"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">variant</span>&amp;&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-3"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">U</span>&amp;&amp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; <a href="#eggs-variant-assign-4">emplace</a>(<span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; <a href="#eggs-variant-assign-5">emplace</a>(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; <a href="#eggs-variant-assign-6">emplace</a>(<span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; <a href="#eggs-variant-assign-7">emplace</a>(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">// Swap</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <a href="#eggs-variant-swap-1">swap</a>(<span style="color:#2b91af;">variant</span>&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);

&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">// Observers</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-obs-1"><span style="color:blue;">operator</span> <span style="color:blue;">bool</span></a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> <a href="#eggs-variant-obs-2">which</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">type_info</span> <span style="color:blue;">const</span>&amp; <a href="#eggs-variant-obs-3">target_type</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span>* <a href="#eggs-variant-obs-4">target</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <span style="color:blue;">const</span>* <a href="#eggs-variant-obs-5">target</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>* <a href="#eggs-variant-obs-6">target</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>* <a href="#eggs-variant-obs-7">target</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;};

&nbsp;&nbsp;<span style="color:green;">// Class bad_variant_access</span>
&nbsp;&nbsp;<span style="color:blue;">class</span> <a href="#eggs-bad-variant-access"><span style="color:#2b91af;">bad_variant_access</span></a> : <span style="color:blue;">public</span> std::<span style="color:#2b91af;">exception</span> {
&nbsp;&nbsp;<span style="color:blue;">public</span>:
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#eggs-bad-variant-access-cnstr-1">bad_variant_access</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">char</span> <span style="color:blue;">const</span>* <a href="#eggs-bad-variant-access-obs-1">what</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span> <span style="color:blue;">override</span>;
&nbsp;&nbsp;};

&nbsp;&nbsp;<span style="color:green;">// Helper classes</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-1"><span style="color:#2b91af;">variant_size</span></a>;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-2"><span style="color:#2b91af;">variant_size</span></a>&lt;<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-3"><span style="color:#2b91af;">variant_size</span></a>&lt;<span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&gt;;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> variant_size_v = <span style="color:#2b91af;">variant_size</span>&lt;T&gt;::value;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-4"><span style="color:#2b91af;">variant_element</span></a>; <span style="color:green;">// undefined</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-5"><span style="color:#2b91af;">variant_element</span></a>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-helper-6"><span style="color:#2b91af;">variant_element</span></a>&lt;I, <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&gt;;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">using</span> <span style="color:#2b91af;">variant_element_t</span> = <span style="color:blue;">class</span> <span style="color:#2b91af;">variant_element</span>&lt;I, <span style="color:#2b91af;">T</span>&gt;::<span style="color:#2b91af;">type</span>;

&nbsp;&nbsp;<span style="color:green;">// Element access</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;&amp; <a href="#eggs-elem-1">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt; <span style="color:blue;">const</span>&amp; <a href="#eggs-elem-2">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;&amp;&amp; <a href="#eggs-elem-3">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt; <span style="color:blue;">const</span>&amp;&amp; <a href="#eggs-elem-4">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; <a href="#eggs-elem-5">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&amp; <a href="#eggs-elem-6">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp;&amp; <a href="#eggs-elem-7">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&amp;&amp; <a href="#eggs-elem-8">get</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;&amp;);

&nbsp;&nbsp;<span style="color:green;">// Relational operators</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-1">operator==</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-2">operator!=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-3">operator&lt;</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-4">operator&gt;</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-5">operator&lt;=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-1-6">operator&gt;=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);

&nbsp;&nbsp;<span style="color:green;">// Comparison with Ts</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-1">operator==</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-2">operator==</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-3">operator!=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-4">operator!=</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-5">operator&lt;</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-6">operator&lt;</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-7">operator&gt;</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-8">operator&gt;</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-9">operator&lt;=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-10">operator&lt;=</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-11">operator&gt;=</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <a href="#eggs-rel-2-12">operator&gt;=</a>(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;);

&nbsp;&nbsp;<span style="color:green;">// Calling a function with variants of arguments</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">R</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">F</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Vs</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">R</span> <a href="#eggs-apply-1">apply</a>(<span style="color:#2b91af;">F</span>&amp;&amp;, <span style="color:#2b91af;">Vs</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">F</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Vs</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <em>see below</em> <a href="#eggs-apply-1">apply</a>(<span style="color:#2b91af;">F</span>&amp;&amp;, <span style="color:#2b91af;">Vs</span>&amp;&amp;...);

&nbsp;&nbsp;<span style="color:green;">// Specialized algorithms</span>
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <a href="#eggs-special-1">swap</a>(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);
}}
<span style="color:green;">// Hash support</span>
<span style="color:blue;">namespace</span> std {
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">struct</span> <a href="#eggs-hash-1"><span style="color:#2b91af;">hash</span></a>&lt;::eggs::variants::<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;
}
<span style="color:blue;">namespace</span> eggs {
&nbsp;&nbsp;<span style="color:blue;">using</span> variants::<span style="color:#2b91af;">variant</span>;
}
</pre>
            </section>

            <section>
                <a name="eggs-variant" href="#eggs-variant"><h1>Class template <code>variant</code></h1></a>
<pre class="code">
<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...<span style="color:#2b91af;">Ts</span>&gt;
<span style="color:blue;">class</span> <span style="color:#2b91af;">variant</span> {
<span style="color:blue;">public</span>:
&nbsp;&nbsp;<span style="color:blue;">static</span> <span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> <span style="color:magenta;">npos</span> = std::<span style="color:#2b91af;">size_t</span>(<span style="color:magenta;">-1</span>);

&nbsp;&nbsp;<span style="color:green;">// Constructors</span>
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-1">variant</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-2">variant</a>(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-3">variant</a>(<span style="color:#2b91af;">variant</span>&amp;&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <a href="#eggs-variant-cnstr-4">variant</a>(<span style="color:#2b91af;">U</span>&amp;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-5">variant</a>(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-6">variant</a>(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-7">variant</a>(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-cnstr-8">variant</a>(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);

&nbsp;&nbsp;<span style="color:green;">// Destructor</span>
&nbsp;&nbsp;<a href="#eggs-variant-dtor-1">~variant</a>();

&nbsp;&nbsp;<span style="color:green;">// Assignment</span>
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-1"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp;);
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-2"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">variant</span>&amp;&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <a href="#eggs-variant-assign-3"><span style="color:blue;">operator</span>=</a>(<span style="color:#2b91af;">U</span>&amp;&amp;);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; <a href="#eggs-variant-assign-4">emplace</a>(<span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; <a href="#eggs-variant-assign-5">emplace</a>(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; <a href="#eggs-variant-assign-6">emplace</a>(<span style="color:#2b91af;">Args</span>&amp;&amp;...);
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>, <span style="color:blue;">class</span> <span style="color:#2b91af;">U</span>, <span style="color:blue;">class</span> ...<span style="color:#2b91af;">Args</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; <a href="#eggs-variant-assign-7">emplace</a>(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt;, <span style="color:#2b91af;">Args</span>&amp;&amp;...);

&nbsp;&nbsp;<span style="color:green;">// Swap</span>
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <a href="#eggs-variant-swap-1">swap</a>(<span style="color:#2b91af;">variant</span>&amp;) <span style="color:blue;">noexcept</span>(<em>see below</em>);

&nbsp;&nbsp;<span style="color:green;">// Observers</span>
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <a href="#eggs-variant-obs-1"><span style="color:blue;">operator</span> <span style="color:blue;">bool</span></a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> <a href="#eggs-variant-obs-2">which</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">type_info</span> <span style="color:blue;">const</span>&amp; <a href="#eggs-variant-obs-3">target_type</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span>* <a href="#eggs-variant-obs-4">target</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <span style="color:blue;">const</span>* <a href="#eggs-variant-obs-5">target</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>* <a href="#eggs-variant-obs-6">target</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
&nbsp;&nbsp;<span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>* <a href="#eggs-variant-obs-7">target</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;
};
</pre>
                <p>In a <code>variant</code>, at most one of the members can be active at any time, that is, the value of at most one of the members can be stored in a <code>variant</code> at any time. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a region of the <code>variant&lt;Ts...&gt;</code> storage suitably aligned for the types <code>Ts...</code>.</p>
                <p>All <code>T</code> in <code>Ts...</code> shall be object types and shall satisfy the requirements of <em><code>Destructible</code></em>.</p>

                <a name="eggs-variant-cnstr" href="#eggs-variant-cnstr"><h2>Constructors</h2></a>

                <a name="eggs-variant-cnstr-1"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> variant() <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Postconditions:</em> <code>*this</code> does not have an active member.</li>
                    <li><em>Remarks:</em> No member is initialized. For every object types <code>Ts...</code> this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-2"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> variant(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>std::is_copy_constructible_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> If <code>rhs</code> has an active member of type <code>T</code>, initializes the active member as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>*rhs.target&lt;T&gt;()</code>; otherwise, no member is initialized.</li>
                    <li><em>Postconditions:</em> <code>rhs.which() == this-&gt;which()</code>.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <code>T</code>.</li>
                    <li><em>Remarks:</em> If <code>std::is_trivially_copyable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this copy constructor shall be a trivial <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-3"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> variant(<span style="color:#2b91af;">variant</span>&amp;&amp; rhs) <span style="color:blue;">noexcept</span>(<em>see below</em>);</pre>
                <ul>
                    <li><em>Requires:</em> <code>std::is_move_constructible_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> If <code>rhs</code> has an active member of type <code>T</code>, initializes the active member as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*rhs.target&lt;T&gt;())</code>; otherwise, no member is initialized. <code>bool(rhs)</code> is unchanged.</li>
                    <li><em>Postconditions:</em> <code>rhs.which() == this-&gt;which()</code>.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <code>T</code>.</li>
                    <li><em>Remarks:</em> The expression inside <code>noexcept</code> is equivalent to the logical <em>AND</em> of <code>std::is_nothrow_move_constructible_v&lt;Ts&gt;...</code>.  If <code>std::is_trivially_copyable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this move constructor shall be a trivial <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> variant(<span style="color:#2b91af;">U</span>&amp;&amp; v);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U&&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>std::is_constructible_v&lt;<em>T</em>, U&amp;&amp;&gt;</code> is <code>true</code>.</li>
                    <li><em>Effects:</em> Initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the expression <code>std::forward&lt;U&gt;(v)</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <em><code>T</code></em>.</li>
                    <li><em>Remarks:</em> This constructor shall not participate in overload resolution unless <code>std::is_same_v&lt;std::decay_t&lt;U&gt;, variant&gt;</code> is <code>false</code>, and there is a type <code>T</code> in <code>Ts...</code> for which <code>U&&</code> is unambiguously convertible to by overload resolution rules. If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> variant(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be the <code>I</code>th element in <code>Ts...</code>, where indexing is zero-based.</li>
                    <li><em><em>Requires:</em></em> <code>I &lt; sizeof...(Ts)</code> and <code>std::is_constructible_v&lt;<em>T</em>, Args&amp;&amp;...&gt;</code> is <code>true</code>.</li>
                    <li><em>Effects:</em> Initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the arguments <code>std::forward&lt;Args&gt;(args)...</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member of type <em><code>T</code></em>.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <em><code>T</code></em>.</li>
                    <li><em>Remarks:</em> If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> variant(<span style="color:#2b91af;">in_place_index_t</span>&lt;<span style="color:#2b91af;">I</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt; il, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be the <code>I</code>th element in <code>Ts...</code>, where indexing is zero-based.</li>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code> and <code>std::is_constructible_v&lt;<em>T</em>, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>.</li>
                    <li><em>Effects:</em> Initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the arguments <code>il, std::forward&lt;Args&gt;(args)...</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member of type <em><code>T</code></em>.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <em><code>T</code></em>.</li>
                    <li><em>Remarks:</em> This constructor shall not participate in overload resolution unless <code>std::is_constructible_v&lt;<em>T</em>, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>. If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-7"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> variant(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li><em>Requires:</em> <code>T</code> shall occur exactly once in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> Equivalent to <code>variant(in_place&lt;I&gt;, std::forward&lt;Args&gt;(args)...)</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-cnstr-8"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> variant(<span style="color:#2b91af;">in_place_type_t</span>&lt;<span style="color:#2b91af;">T</span>&gt;</span>, std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt; il, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li><em>Requires:</em> <code>T</code> shall occur exactly once in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> Equivalent to <code>variant(in_place&lt;I&gt;, il, std::forward&lt;Args&gt;(args)...)</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This constructor shall not participate in overload resolution unless <code>std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>. If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</li>
                </ul>

                <a name="eggs-variant-dtor" href="#eggs-variant-dtor"><h2>Destructor</h2></a>

                <a name="eggs-variant-dtor-1"></a>
                <pre class="code">~variant();</pre>
                <ul>
                    <li><em>Effects:</em> If <code>*this</code> has an active member of type <code>T</code>, destroys the active member as if by calling <code>target&lt;T&gt;()-&gt;~T()</code>.</li>
                    <li><em>Remarks:</em> If <code>std::is_trivially_destructible_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this destructor shall be trivial.</li>
                </ul>

                <a name="eggs-variant-assign" href="#eggs-variant-assign"><h2>Assignment</h2></a>

                <a name="eggs-variant-assign-1"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <span style="color:blue;">operator</span>=(<span style="color:#2b91af;">variant</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>std::is_copy_constructible_v&lt;T&gt;</code> and <code>std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li>
                        <em>Effects:</em>
                        <ul>
                            <li>If both <code>*this</code> and <code>rhs</code> have an active member of type <code>T</code>, assigns to the active member the expression <code>*rhs.target&lt;T&gt;()</code>;</li>
                            <li>otherwise, if <code>*this</code> has an active member of type <code>U</code>, destroys the active member by calling <code>target&lt;U&gt;()->~U()</code>. Then, if <code>rhs</code> has an active member of type <code>T</code>, initializes the active member as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>*rhs.target&lt;T&gt;()</code>.</li>
                        </ul>
                    </li>
                    <li><em>Returns:</em> <code>*this</code>.</li>
                    <li><em>Postconditions:</em> <code>rhs.which() == this-&gt;which()</code>.</li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to <code>T</code>'s copy assignment, the state of the active member is as defined by the exception safety guarantee of <code>T</code>'s copy assignment. If an exception is thrown during the call to <code>T</code>'s copy constructor, <code>*this</code> has no active member, and the previous active member (if any) has been destroyed. If <code>std::is_trivially_copyable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this copy assignment operator shall be a trivial <code>constexpr</code> assignment operator.</li>
                </ul>

                <a name="eggs-variant-assign-2"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant</span>&amp; <span style="color:blue;">operator</span>=(<span style="color:#2b91af;">variant</span>&amp;&amp; rhs) <span style="color:blue;">noexcept</span>(<em>see below</em>);</pre>
                <ul>
                    <li><em>Requires:</em> <code>std::is_move_constructible_v&lt;T&gt;</code> and <code>std::is_move_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li>
                        <em>Effects:</em>
                        <ul>
                            <li>If both <code>*this</code> and <code>rhs</code> have an active member of type <code>T</code>, assigns to the active member the expression <code>std::move(*rhs.target&lt;T&gt;())</code>;</li>
                            <li>otherwise, if <code>*this</code> has an active member of type <code>U</code>, destroys the active member by calling <code>target&lt;U&gt;()->~U()</code>. Then, if <code>rhs</code> has an active member of type <code>T</code>, initializes the active member as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*rhs.target&lt;Tn&gt;())</code>.</li>
                        </ul>
                    </li>
                    <li><code>bool(rhs)</code> is unchanged.</li>
                    <li><em>Returns:</em> <code>*this</code>.</li>
                    <li><em>Postconditions:</em> <code>rhs.which() == this-&gt;which()</code>.</li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to <code>T</code>'s move assignment, the state of both active members is determined by the exception safety guarantee of <code>T</code>'s move assignment. If an exception is thrown during the call to <code>T</code>'s move constructor, <code>*this</code> has no active member, the previous active member (if any) has been destroyed, and the state of the active member of <code>rhs</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor. The expression inside <code>noexcept</code> is equivalent to the logical <em>AND</em> of <code>std::is_nothrow_move_assignable_v&lt;Ts&gt;...</code> and <code>std::is_nothrow_move_constructible_v&lt;Ts&gt;...</code>. If <code>std::is_trivially_copyable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this move assignment operator shall be a trivial <code>constexpr</code> assignment operator.</li>
                </ul>

                <a name="eggs-variant-assign-3"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> variant&amp; <span style="color:blue;">operator</span>=(<span style="color:#2b91af;">U</span>&amp;&amp; v);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U&&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>std::is_constructible_v&lt;T, U&amp;&amp;&gt;</code> and <code>std::is_assignable_v&lt;<em>T</em>, U&amp;&amp;&gt;</code> are <code>true</code>.</li>
                    <li>
                        <em>Effects:</em>
                        <ul>
                            <li>If <code>*this</code> has an active member of type <em><code>T</code></em>, assigns to the active member the expression <code>std::forward&lt;U&gt;(v)</code>;</li>
                            <li>otherwise, calls <code>*this = {}</code>. Then, initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the expression <code>std::forward&lt;U&gt;(v)</code>.</li>
                        </ul>
                    </li>
                    <li><em>Returns:</em> <code>*this</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member.</li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to <em><code>T</code></em>'s assignment, the state of the active member is as defined by the exception safety guarantee of <em><code>T</code></em>'s copy assignment. If an exception is thrown during the call to <em><code>T</code></em>'s constructor, <code>*this</code> has no active member, and the previous active member (if any) has been destroyed. This operator shall not participate in overload resolution unless <code>std::is_same_v&lt;std::decay_t&lt;U&gt;, variant&gt;</code> is <code>false</code>, and there is a type <code>T</code> in <code>Ts...</code> for which <code>U&&</code> is unambiguously convertible to by overload resolution rules. If <code>std::is_trivially_copyable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code> and <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-assign-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; emplace(<span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be the <code>I</code>th element in <code>Ts...</code>, where indexing is zero-based.</li>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code> and <code>std::is_constructible_v&lt;<em>T</em>, Args&amp;&amp;...&gt;</code> is <code>true</code>.</li>
                    <li><em>Effects:</em> Calls <code>*this = {}</code>. Then, initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the arguments <code>std::forward&lt;Args&gt;(args)...</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member of type <em><code>T</code></em>.</li>
                    <li><em>Returns:</em> A reference to the new contained value.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <em><code>T</code></em>.</li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to <em><code>T</code></em>'s constructor, <code>*this</code> has no active member, and the previous active member (if any) has been destroyed. If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code> and <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-assign-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;"><em>T</em></span>&amp; emplace(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt; il, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be the <code>I</code>th element in <code>Ts...</code>, where indexing is zero-based.</li>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code> and <code>std::is_constructible_v&lt;<em>T</em>, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>.</li>
                    <li><em>Effects:</em> Calls <code>*this = {}</code>. Then, initializes the active member as if direct-non-list-initializing an object of type <em><code>T</code></em> with the arguments <code>il, std::forward&lt;Args&gt;(args)...</code>.</li>
                    <li><em>Postconditions:</em> <code>*this</code> has an active member of type <em><code>T</code></em>.</li>
                    <li><em>Returns:</em> A reference to the new contained value.</li>
                    <li><em>Throws:</em> Any exception thrown by the selected constructor of <em><code>T</code></em>.</li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to <em><code>T</code></em>'s constructor, <code>*this</code> has no active member, and the previous active member (if any) has been destroyed. This function shall not participate in overload resolution unless <code>std::is_constructible_v&lt;<em>T</em>, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>. If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code> and <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-assign-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; emplace(<span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li><em>Requires:</em> <code>T</code> shall occur exactly once in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> Equivalent to <code>emplace&lt;I&gt;(std::forward&lt;Args&gt;(args)...)</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code> and <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-assign-7"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Args&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; emplace(std::<span style="color:#2b91af;">initializer_list</span>&lt;<span style="color:#2b91af;">U</span>&gt; il, <span style="color:#2b91af;">Args</span>&amp;&amp;... args);</pre>
                <ul>
                    <li><em>Requires:</em> <code>T</code> shall occur exactly once in <code>Ts...</code>.</li>
                    <li><em>Effects:</em> Equivalent to <code>emplace&lt;I&gt;(il, std::forward&lt;Args&gt;(args)...)</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This function shall not participate in overload resolution unless <code>std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> is <code>true</code>. If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code> and <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-swap" href="#eggs-variant-swap"><h2>Swap</h2></a>

                <a name="eggs-variant-swap-1"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> swap(<span style="color:#2b91af;">variant</span>&amp; rhs) <span style="color:blue;">noexcept</span>(<em>see below</em>);</pre>
                <ul>
                    <li><em>Requires:</em> Lvalues of <code>T</code> shall be swappable and <code>std::is_move_constructible_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li>
                        <em>Effects:</em>
                        <ul>
                            <li>If both <code>*this</code> and <code>rhs</code> have an active member of type <code>T</code>, calls <code>swap(*this-&gt;target&lt;T&gt;(), *rhs.target&lt;T&gt;())</code>;</li>
                            <li>otherwise, calls <code>std::swap(*this, rhs)</code>.</li>
                        </ul>
                    </li>
                    <li><em>Remarks:</em> If an exception is thrown during the call to function <code>swap</code> the state of the active members of type <code>T</code> is determined by the exception safety guarantee of <code>swap</code> for lvalues of <code>T</code>. If an exception is thrown during the call to a move constructor, the state of <code>*this</code> and <code>rhs</code> is unspecified. The expression inside <code>noexcept</code> is equivalent to the logical <em>AND</em> of <code>std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_swappable_v&lt;T&gt;</code> for all <code>T</code> in <code>Ts...</code>. If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs" href="#eggs-variant-obs"><h2>Observers</h2></a>

                <a name="eggs-variant-obs-1"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:blue;">explicit</span> <span style="color:blue;">operator</span> <span style="color:blue;">bool</span>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> <code>true</code> if and only if <code>*this</code> has an active member.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-2"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">size_t</span> which() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> The zero-based index of the active member if <code>*this</code> has one. Otherwise, returns <code>npos</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-3"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> std::<span style="color:#2b91af;">type_info</span> <span style="color:blue;">const</span>&amp; target_type() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> If <code>*this</code> has an active member of type <code>T</code>, <code>typeid(T)</code>; otherwise <code>typeid(void)</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-4"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:blue;">void</span>* target() <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> If <code>*this</code> has an active member, a pointer to the active member; otherwise a null pointer.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-5"></a>
                <pre class="code"><span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> <span style="color:blue;">const</span>* target() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> If <code>*this</code> has an active member, a pointer to the active member; otherwise a null pointer.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>* target() <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> If <code>*this</code> has an active member of type <code>T</code>, a pointer to the active member; otherwise a null pointer.</li>
                    <li><em>Remarks:</em> Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-variant-obs-7"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>* target() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Returns:</em> If <code>*this</code> has an active member of type <code>T</code>, a pointer to the active member; otherwise a null pointer.</li>
                    <li><em>Remarks:</em> Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, this function shall be a <code>constexpr</code> function.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-inplace" href="#eggs-inplace"><h1>In-place construction</h1></a>
<pre class="code">
<span style="color:blue;">struct</span> <span style="color:#2b91af;">in_place_tag</span> {};
<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I&gt;
<span style="color:blue;">using</span> <a href="#eggs-inplace"><span style="color:#2b91af;">in_place_index_t</span></a> = <span style="color:#2b91af;">in_place_tag</span>(&amp;)(<em>unspecified&lt;<span style="color:#2b91af;">I</span>&gt;</em>);
<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
<span style="color:blue;">using</span> <a href="#eggs-inplace"><span style="color:#2b91af;">in_place_type_t</span></a> = <span style="color:#2b91af;">in_place_tag</span>(&amp;)(<em>unspecified&lt;<span style="color:#2b91af;">T</span>&gt;</em>);
<span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I&gt;
<span style="color:#2b91af;">in_place_tag</span> <span style="color:magenta;">in_place</span>(<em>unspecified&lt;<span style="color:#2b91af;">I&gt;</span></em>);
<span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> <span style="color:#2b91af;">T</span>&gt;
<span style="color:#2b91af;">in_place_tag</span> <span style="color:magenta;">in_place</span>(<em>unspecified&lt;<span style="color:#2b91af;">T&gt;</span></em>);
</pre>
                <p>The struct <code>in_place_tag</code> is used as a unique type to disambiguate constructor and function overloading. Specifically, <code>variant&lt;Ts...&gt;</code> has a constructor with <code>in_place_type_t&lt;T&gt;</code> as the first parameter, followed by a parameter pack; this indicates that <code>T</code> should be constructed in-place (as if by a call to a placement new expression) with the forwarded pack expansion as arguments for the initialization of <code>T</code>.</p>
            </section>

            <section>
                <a name="eggs-bad-variant-access" href="#eggs-bad-variant-access"><h1>Class <code>bad_variant_access</code></h1></a>
<pre class="code">
<span style="color:blue;">class</span> <span style="color:#2b91af;">bad_variant_access</span> : <span style="color:blue;">public</span> std::<span style="color:#2b91af;">exception</span> {
<span style="color:blue;">public</span>:
&nbsp;&nbsp;<a href="#eggs-bad-variant-access-cnstr-1">bad_variant_access</a>() <span style="color:blue;">noexcept</span>;
&nbsp;&nbsp;<span style="color:blue;">char</span> <span style="color:blue;">const</span>* <a href="#eggs-bad-variant-access-obs-1">what</a>() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span> <span style="color:blue;">override</span>;
};
</pre>
                <p>Objects of type <code>bad_variant_access</code> are thrown to report attempts to access an inactive member of a <code>variant</code> object.</p>

                <a name="eggs-bad-variant-access-cnstr-1"></a>
                <pre class="code">bad_variant_access() <span style="color:blue;">noexcept</span>;</pre>
                <ul>
                    <li><em>Effects:</em> Constructs a <code>bad_variant_access</code> object.</li>
                </ul>

                <a name="eggs-bad-variant-access-obs-1"></a>
                <pre class="code"><span style="color:blue;">char</span> <span style="color:blue;">const</span>* what() <span style="color:blue;">const</span> <span style="color:blue;">noexcept</span> <span style="color:blue;">override</span>;</pre>
                <ul>
                    <li><em>Returns:</em> An implementation-defined NTBS.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-helper" href="#eggs-helper"><h1>Variant helper classes</h1></a>

                <a name="eggs-helper-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_size</span>;</pre>
                <ul>
                    <li><em>Remarks:</em> All specializations of <code>variant_size&lt;T&gt;</code> shall meet the <em><code>UnaryTypeTrait</code></em> requirements with a <em><code>BaseCharacteristic</code></em> of <code>std::integral_constant&lt;std::size_t, N&gt;</code> for some <code>N</code> if <code>T</code> is a <em>variant-like</em> type; otherwise it shall be empty.</li>
                </ul>

                <a name="eggs-helper-2"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_size</span>&lt;<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;</pre>
                <ul>
                    <li><em>Remarks:</em> Has a <em><code>BaseCharacteristic</code></em> of <code>std::integral_constant&lt;std::size_t, sizeof...(Ts)&gt;</code>.</li>
                </ul>

                <a name="eggs-helper-3"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_size</span>&lt;<span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&gt;;</pre>
                <ul>
                    <li><em>Remarks:</em> Let <em><code>VS</code></em> denote <code>variant_size&lt;T&gt;</code> of the cv-unqualified type <code>T</code>. Has a <em><code>BaseCharacteristic</code></em> of <code>std::integral_constant&lt;std::size_t, <em>VS</em>::value&gt;</code> if <code>T</code> is a <em>variant-like</em> type; otherwise it is empty.</li>
                </ul>

                <a name="eggs-helper-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_element</span>;</pre>
                <ul>
                    <li><em>Remarks:</em> All specializations of <code>variant_element&lt;I, T&gt;</code> shall meet the <em><code>TransformationTrait</code></em> requirements with a member typedef <code>type</code> that names the <code>I</code>th member of <code>T</code>, where indexing is zero-based.</li>
                </ul>

                <a name="eggs-helper-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_element</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;</pre>
                <ul>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code>.</li>
                    <li><em>Remarks:</em> The member typedef <code>type</code> shall name the type of the <code>I</code>th element of <code>Ts...</code>, where indexing is zero-based.</li>
                </ul>

                <a name="eggs-helper-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> T&gt;<br /><span style="color:blue;">struct</span> <span style="color:#2b91af;">variant_element</span>&lt;I, <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&gt;;</pre>
                <ul>
                    <li><em>Remarks:</em> Let <em><code>VE</code></em> denote <code>variant_element&lt;I, T&gt;</code> of the cv-unqualified type <code>T</code>. The member typedef <code>type</code> names <code>std::add_const_t&lt;typename <em>VE</em>::type&gt;</code>.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-elem" href="#eggs-elem"><h1>Element access</h1></a>

                <a name="eggs-elem-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp; v);</pre>
                <ul>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code>.</li>
                    <li><em>Returns:</em> A reference to the <code>I</code>th member of <code>v</code> if it is active, where indexing is zero-based.</li>
                    <li><em>Throws:</em> <code>bad_variant_access</code> if the <code>I</code>th member of <code>v</code> is not active.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-2"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt; <span style="color:blue;">const</span>&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; v);</pre>
                <ul>
                    <li><em>Requires:</em> <code>I &lt; sizeof...(Ts)</code>.</li>
                    <li><em>Returns:</em> A const reference to the <code>I</code>th member of <code>v</code> if it is active, where indexing is zero-based.</li>
                    <li><em>Throws:</em> <code>bad_variant_access</code> if the <code>I</code>th member of <code>v</code> is not active.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-3"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;&amp;&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;&amp; v);</pre>
                <ul>
                    <li><em>Effects:</em> Equivalent to return <code>std::forward&lt;variant_element_t&lt;I, variant&lt;Ts...&gt;&gt;&gt;(get&lt;I&gt;(v))</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;std::<span style="color:#2b91af;">size_t</span> I, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">variant_element_t</span>&lt;I, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt; <span style="color:blue;">const</span>&amp;&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;&amp; v);</pre>
                <ul>
                    <li><em>Effects:</em> Equivalent to return <code>std::forward&lt;variant_element_t&lt;I, variant&lt;Ts...&gt;&gt; const&gt;(get&lt;I&gt;(v))</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp; v);</pre>
                <ul>
                    <li><em>Requires:</em> The type <code>T</code> occurs exactly once in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> A reference to the active member of <code>v</code> if it is of type <code>T</code>.</li>
                    <li><em>Throws:</em> <code>bad_variant_access</code> if the active member of <code>v</code> is not of type <code>T</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; v);</pre>
                <ul>
                    <li><em>Requires:</em> The type <code>T</code> occurs exactly once in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> A const reference to the active member of <code>v</code> if it is of type <code>T</code>.</li>
                    <li><em>Throws:</em> <code>bad_variant_access</code> if the active member of <code>v</code> is not of type <code>T</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-7"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span>&amp;&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp;&amp; v);</pre>
                <ul>
                    <li><em>Effects:</em> Equivalent to return <code>std::forward&lt;T&gt;(get&lt;T&gt;(v))</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-elem-8"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> T, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">T</span> <span style="color:blue;">const</span>&amp;&amp; get(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp;&amp; v);</pre>
                <ul>
                    <li><em>Effects:</em> Equivalent to return <code>std::forward&lt;T const&gt;(get&lt;T&gt;(v))</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-rel-1" href="#eggs-rel-1"><h1>Relational operators</h1></a>

                <a name="eggs-rel-1-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>==(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() == *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>lhs.which() != rhs.which()</code>, <code>false</code>; otherwise, if <code>!bool(lhs)</code>, <code>true</code>; otherwise, <code>*lhs.target&lt;T&gt;() == *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() == *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-1-2"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>!=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() != *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>lhs.which() != rhs.which()</code>, <code>true</code>; otherwise, if <code>!bool(lhs)</code>, <code>false</code>; otherwise, <code>*lhs.target&lt;T&gt;() != *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() != *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-1-3"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &lt; *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>false</code>; otherwise, if <code>!bool(lhs)</code>, <code>true</code>; otherwise, if <code>lhs.which() == rhs.which()</code>, <code>*lhs.target&lt;T&gt;() &lt; *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>; otherwise, <code>lhs.which() &lt; rhs.which()</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() &lt; *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-1-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &gt; *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>false</code>; otherwise, if <code>!bool(rhs)</code>, <code>true</code>; otherwise, if <code>lhs.which() == rhs.which()</code>, <code>*lhs.target&lt;T&gt;() &gt; *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>; otherwise, <code>lhs.which() &gt; rhs.which()</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() &gt; *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-1-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &lt;= *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>true</code>; otherwise, if <code>!bool(rhs)</code>, <code>false</code>; otherwise, if <code>lhs.which() == rhs.which()</code>, <code>*lhs.target&lt;T&gt;() &lt;= *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>; otherwise, <code>lhs.which() &lt; rhs.which()</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() &lt;= *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-1-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &gt;= *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code> for all <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>true</code>; otherwise, if <code>!bool(lhs)</code>, <code>false</code>; otherwise, if <code>lhs.which() == rhs.which()</code>, <code>*lhs.target&lt;T&gt;() &gt;= *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code>; otherwise, <code>lhs.which() &gt; rhs.which()</code>.</li>
                    <li><em>Remarks:</em> This function shall be a <code>constexpr</code> function unless <code>lhs.which() == rhs.which()</code> and <code>*lhs.target&lt;T&gt;() &gt;= *rhs.target&lt;T&gt;()</code> where <code>T</code> is the type of the active member of both <code>lhs</code> and <code>rhs</code> is not a constant expression.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-rel-2" href="#eggs-rel-2"><h1>Comparison with <code>Ts</code></h1></a>

                <a name="eggs-rel-2-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>==(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() == rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() == rhs</code>; otherwise, <code>false</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() == rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-2"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>==(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs == *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>rhs</code> has an active member of type <code>T</code>, <code>lhs == *rhs.target&lt;T&gt;()</code>; otherwise, <code>false</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs == *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-3"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>!=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() != rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() != rhs</code>; otherwise, <code>true</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() != rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-4"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>!=(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs != *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>rhs</code> has an active member of type <code>T</code>, <code>lhs == *rhs.target&lt;T&gt;()</code>; otherwise, <code>true</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs != *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-5"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &lt; rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>true</code>; otherwise, if <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() &lt; rhs</code>; otherwise, <code>lhs.which() &lt; I</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() &lt; rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-6"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs &lt; *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>false</code>; otherwise, if <code>rhs</code> has an active member of type <code>T</code>, <code>lhs &lt; *rhs.target&lt;T&gt;()</code>; otherwise, <code>I &lt; rhs.which()</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs &lt; *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-7"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &gt; rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>false</code>; otherwise, if <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() &gt; rhs</code>; otherwise, <code>lhs.which() &gt; I</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() &gt; rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-8"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs &gt; *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>true</code>; otherwise, if <code>rhs</code> has an active member of type <code>T</code>, <code>lhs &gt; *rhs.target&lt;T&gt;()</code>; otherwise, <code>I &gt; rhs.which()</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs &gt; *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-9"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &lt;= rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>true</code>; otherwise, if <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() &lt;= rhs</code>; otherwise, <code>lhs.which() &lt; I</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() &lt;= rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-10"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&lt;=(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs &lt;= *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>false</code>; otherwise, if <code>rhs</code> has an active member of type <code>T</code>, <code>lhs &lt;= *rhs.target&lt;T&gt;()</code>; otherwise, <code>I &lt; rhs.which()</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs &lt;= *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-11"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts, <span style="color:blue;">class</span> U&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;=(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>*lhs.target&lt;T&gt;() &gt;= rhs</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(lhs)</code>, <code>false</code>; otherwise, if <code>lhs</code> has an active member of type <code>T</code>, <code>*lhs.target&lt;T&gt;() &gt;= rhs</code>; otherwise, <code>lhs.which() &gt; I</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>lhs</code> has an active member of type <code>T</code> and <code>*lhs.target&lt;T&gt;() &gt;= rhs</code> is not a constant expression.</li>
                </ul>

                <a name="eggs-rel-2-12"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> U, <span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">bool</span> <span style="color:blue;">operator</span>&gt;=(<span style="color:#2b91af;">U</span> <span style="color:blue;">const</span>&amp; lhs, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt; <span style="color:blue;">const</span>&amp; rhs);</pre>
                <ul>
                    <li>Let <em><code>T</code></em> be one of the types in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules.</li>
                    <li><em>Requires:</em> <code>lhs &gt;= *rhs.target&lt;T&gt;()</code> is a valid expression returning a type that is convertible to <code>bool</code>.</li>
                    <li><em>Returns:</em> If <code>!bool(rhs)</code>, <code>true</code>; otherwise, if <code>rhs</code> has an active member of type <code>T</code>, <code>lhs &gt;= *rhs.target&lt;T&gt;()</code>; otherwise, <code>I &gt; rhs.which()</code> where <code>I</code> is the zero-based index of <code>T</code> in <code>Ts...</code>.</li>
                    <li><em>Remarks:</em> This operator shall not participate in overload resolution unless there is a type <code>T</code> in <code>Ts...</code> for which <code>U const&</code> is unambiguously convertible to by overload resolution rules. This function shall be a <code>constexpr</code> function unless <code>rhs</code> has an active member of type <code>T</code> and <code>lhs &gt;= *rhs.target&lt;T&gt;()</code> is not a constant expression.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-apply" href="#eggs-apply"><h1>Calling a function with variants of arguments</h1></a>

                <a name="eggs-apply-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> R, <span style="color:blue;">class</span> F, <span style="color:blue;">class</span> ...Vs&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:#2b91af;">R</span> apply(<span style="color:#2b91af;">F</span>&amp;&amp; f, <span style="color:#2b91af;">Vs</span>&amp;&amp;... vs);</pre>
                <ul>
                    <li>Let <em><code>Vi</code></em> be the <em><code>i</code>-th</em> type in <code>Vs...</code>, <em><code>Ui</code></em> be <code>std::decay_t&lt;<em>Vi</em>&gt;</code>, where all indexing is zero-based.</li>
                    <li><em>Requires:</em> For all <em><code>i</code></em>, <em><code>Ui</code></em> shall be the type <code>variant&lt;<em>Tsi</em>...&gt;</code> where <em><code>Tsi</code></em> is the parameter pack representing the element types in <em><code>Ui</code></em>. <code><em>INVOKE</em>(std::forward&lt;F&gt;(f), get&lt;Is&gt;(std::forward&lt;Vs&gt;(vs))..., R)</code> shall be a valid expression for all <em><code>Is...</code></em> in the range <code>[0u, sizeof... (<em>Tsi</em>))...</code>.</li>
                    <li><em>Effects:</em> Equivalent to <code><em>INVOKE</em>(std::forward&lt;F&gt;(f), get&lt;Is&gt;(std::forward&lt;Vs&gt;(vs))...), R)</code> where <code>Is...</code> are the zero-based indices of the active members of <code>vs...</code>.</li>
                    <li><em>Throws:</em> <code>bad_variant_access</code> if any of <code>vs...</code> has no active member.</li>
                    <li><em>Remarks:</em> If the selected function is a constant expression, then this function shall be a <code>constexpr</code> function.</li>
                </ul>

                <a name="eggs-apply-2"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> F, <span style="color:blue;">class</span> ...Vs&gt;<br /><span style="color:blue;">constexpr</span> <em><span style="color:#2b91af;">R</span></em> apply(<span style="color:#2b91af;">F</span>&amp;&amp; f, <span style="color:#2b91af;">Vs</span>&amp;&amp;... vs);</pre>
                <ul>
                    <li>
                        Let <em><code>Ri...</code></em> be the return types of every potentially evaluated <code><em>INVOKE</em></code> expression; if every <em><code>Ri...</code></em> is the same type, then let <em><code>R</code></em> be that type.
                    </li>
                    <li><em>Effects:</em> Equivalent to <code>apply&lt;<em>R</em>&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Vs&gt;(vs)...)</code>.</li>
                    <li><em>Remarks:</em> This function shall not participate in overload resolution unless the return type of every potentially evaluated <code><em>INVOKE</em></code> expression is the same type. If the selected function is a constant expression, then this function shall be a <code>constexpr</code> function.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-special" href="#eggs-special"><h1>Specialized algorithms</h1></a>

                <a name="eggs-special-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">constexpr</span> <span style="color:blue;">void</span> swap(<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp; x, <span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&amp; y) <span style="color:blue;">noexcept</span>(<span style="color:blue;">noexcept</span>(x.swap(y)));</pre>
                <ul>
                    <li><em>Effects:</em> Calls <code>x.swap(y)</code>.</li>
                    <li><em>Remarks:</em> This function shall be defined as deleted unless <code>std::is_move_constructible_v&lt;T&gt; &amp;&amp; std::is_swappable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>. If <code>std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; std::is_copy_assignable_v&lt;T&gt;</code> is <code>true</code> for all <code>T</code> in <code>Ts...</code>, then this function shall be a <code>constexpr</code> function.</li>
                </ul>
            </section>

            <section>
                <a name="eggs-hash" href="#eggs-hash"><h1>Hash support</h1></a>

                <a name="eggs-hash-1"></a>
                <pre class="code"><span style="color:blue;">template</span> &lt;<span style="color:blue;">class</span> ...Ts&gt;<br /><span style="color:blue;">struct</span> std::<span style="color:#2b91af;">hash</span>&lt;eggs::variants::<span style="color:#2b91af;">variant</span>&lt;<span style="color:#2b91af;">Ts</span>...&gt;&gt;;</pre>
                <ul>
                    <li>
                        The specialization <code>std::hash&lt;variant&lt;Ts...&gt;&gt;</code> is enabled if and only if every specialization in <code>std::hash&lt;std::remove_const_t&lt;Ts&gt;&gt;...</code> is enabled. When enabled, for an object <code>v</code> of type <code>variant&lt;Ts...&gt;</code>, if <code>v</code> has an active member of type <code>T</code>, <code>std::hash&lt;variant&lt;Ts...&gt;&gt;()(v)</code> shall evaluate to the same value as <code>std::hash&lt;T&gt;()(*v.target&lt;T&gt;())</code>; otherwise it evaluates to an unspecified value.
                    </li>
                </ul>
            </section>
        </div>

        <hr>
        <p>
            Copyright
            <em>Agust&iacute;n Berg&eacute;</em>,
            <em>Fusion Fenix</em> 2014-2017
        </p>

        <p>
            Distributed under the Boost Software License, Version 1.0. (See accompanying
            file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
        </p>
    </div>
</body>
</html>
